"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var schemas = require("./addresses.x");
var constants = require("../../../constants");
var Money_1 = require("../../../classes/Money");
/** TEMPORARY MOCKS */
var addresses_1 = require("../v1/addresses");
var aliases_1 = require("../v1/aliases");
var assets_1 = require("../v1/assets");
var transactions_1 = require("../v1/transactions");
var _combiners_1 = require("./_combiners");
var _filters_1 = require("./_filters");
var _frame_1 = require("./_frame");
var _warn_1 = require("./_warn");
exports.default = {
    get: function (address) {
        _warn_1.default();
        var balanceDetails = addresses_1.default.balanceDetails(address).then(function (data) {
            return schemas.detailedWavesBalanceSchema.parse(data);
        });
        var aliasesByAddress = aliases_1.default.byAddress(address).then(function (data) {
            return schemas.aliasesByAddressSchema.parse(data);
        });
        return Promise.all([balanceDetails, aliasesByAddress]).then(function (results) {
            return {
                wavesBalance: results[0],
                aliases: results[1]
            };
        });
    },
    balances: function (address, options) {
        if (options === void 0) { options = {}; }
        _warn_1.default();
        var wavesBalance = addresses_1.default.balance(address).then(function (data) {
            return Money_1.default.fromCoins(String(data.balance), constants.WAVES).then(function (amount) {
                return [__assign({}, constants.WAVES_PROPS, { amount: amount })];
            });
        });
        var assetBalances = assets_1.default.balances(address).then(function (data) {
            return schemas.assetBalancesSchema.parse(data).then(function (balances) {
                return balances.sort(function (a, b) { return a.id > b.id ? -1 : 1; });
            });
        });
        return Promise.all([wavesBalance, assetBalances])
            .then(function (results) { return results[0].concat(results[1]); })
            .then(function (array) {
            if (options.assets) {
                return _combiners_1.default.balanceListByAssets(array, options.assets);
            }
            else {
                return _frame_1.default(array, options.offset, options.limit);
            }
        });
    },
    transactions: function (address, options) {
        if (options === void 0) { options = {}; }
        _warn_1.default('This method is currently able to return only 1000 last transactions.');
        return transactions_1.default.getList(address, options.limit).then(function (array) {
            array = array[0]; // Strange response artifact
            if (options.type) {
                array = array.filter(_filters_1.default.transactionType(options.type));
            }
            if (options.sender) {
                array = array.filter(_filters_1.default.transactionSender(options.sender));
            }
            if (options.recipient) {
                array = array.filter(_filters_1.default.transactionRecipient(options.recipient));
            }
            return array;
        }).then(function (filteredArray) {
            return Promise.all(filteredArray.map(function (item) {
                switch (item.type) {
                    case constants.ISSUE_TX:
                        return schemas.issueTransactionSchema.parse(item);
                    case constants.TRANSFER_TX:
                        return schemas.transferTransactionSchema.parse(item);
                    case constants.REISSUE_TX:
                        return schemas.reissueTransactionSchema.parse(item);
                    case constants.BURN_TX:
                        return schemas.burnTransactionSchema.parse(item);
                    case constants.EXCHANGE_TX:
                        return schemas.exchangeTransactionSchema.parse(item);
                    case constants.LEASE_TX:
                        return schemas.leaseTransactionSchema.parse(item);
                    case constants.CANCEL_LEASING_TX:
                        return schemas.cancelLeasingTransactionSchema.parse(item);
                    case constants.CREATE_ALIAS_TX:
                        return schemas.createAliasTransactionSchema.parse(item);
                    default:
                        throw new Error("Unknown transaction type encountered: " + item.type);
                }
            }));
        });
    }
};
//# sourceMappingURL=addresses.js.map